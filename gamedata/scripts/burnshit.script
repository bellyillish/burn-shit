local FUNC = custom_functor_autoinject


local BS = {
  -- "whoosh" sound when burning shit
  sound = sound_object("burnshit\\fire_whoosh"),

  -- additional items (by section name) to make burnable/not burnable
  -- overrides canBurnQuestItems and canBurnNonTradeableItems
  overrides = {
    -- example_section = false,
    -- another_section = true,
  },

  -- MCM options
  options = {
    showBurnAll      = "always",
    burnQuestItems   = false,
    burnUntradeables = true,
    menuRange        = 3.2,
    dragDropRange    = 1.6,
    minVolume        = 0.48,
    maxVolume        = 0.88,
  }
}


function BS.option(name)
  return ui_mcm and ui_mcm.get("burnshit/" .. name)
    or BS.options[name]
end


function BS.refreshInventory()
  local inventory = GetActorMenu()

  if inventory then
    inventory:UnHighlight_All()
    inventory:UpdateItems()
  end
end


function BS.closestCampfire(pos, range)
  local campfire

  for id, binders in pairs(bind_campfire.campfires_all) do
    local dist = pos:distance_to(binders.object:position())

    if dist <= range and binders.campfire:is_on() then
      return {
        id       = id,
        dist     = dist,
        object   = binders.object,
        campfire = binders.campfire,
      }
    end
  end
end


function BS.burnable(item)
  local inventory = GetActorMenu()

  if not inventory or not inventory:IsShown() or inventory.mode ~= "inventory" then
    return false
  end

  if item:get_max_uses() > 0 and item:get_remaining_uses() == 0 then
    return false
  end

  if BS.overrides[item:section()] ~= nil then
    return BS.overrides[item:section()]
  end

  local questItem = SYS_GetParam(1, item:section(), "quest_item") == true
  local tradeable = SYS_GetParam(1, item:section(), "can_trade")  == true

  if questItem and not BS.option("burnQuestItems") then
    return false
  end

  if not tradeable and not BS.option("burnUntradeables") then
    return false
  end

  return true
end


function BS.showMenu(item)
  local range = BS.option("menuRange")
  local pos   = db.actor:position()

  return range > 0
    and BS.closestCampfire(pos, range) ~= nil
    and BS.burnable(item)
end


function BS.showMenuAll(item)
  local showAll = BS.option("showBurnAll")
  local range   = BS.option("menuRange")
  local pos     = db.actor:position()

  if range == 0 or showAll == "never" then
    return false
  end

  if not BS.closestCampfire(pos, range) or not BS.burnable(item) then
    return false
  end

  if showAll == "always" then
    return true
  end

  local count = 0

  db.actor:iterate_inventory(function(owner, other)
    if item:section() == other:section() then
      count = count + 1
      if count > 1 then
        return true
      end
    end
  end, db.actor)

  return count > 1
end


function BS.burn(ids, parentCheck)
  local minVolume = BS.option("minVolume")
  local maxVolume = BS.option("maxVolume")

  CreateTimeEvent(ids[1], "burnshit", 0.1, function(ids)
    local burnCount = #ids

    for i, id in ipairs(ids) do
      local item = level.object_by_id(id)

      if not item or parentCheck == true and item:parent() then
        burnCount = burnCount - 1
      else
        alife_release(item)
      end
    end

    burnCount = math.min(burnCount, 10)

    if minVolume > maxVolume then
      minVolume = maxVolume
    end

    if burnCount == 0 or maxVolume == 0 then
      return true
    end

    local volume = minVolume + ((maxVolume - minVolume) / 9) * (burnCount - 1)

    BS.sound:play_no_feedback(db.actor, 0, 0, db.actor:position(), volume, 1.0)
    BS.refreshInventory()

    return true
  end, ids)
end


function BS.onDropItem(item)
  local range = BS.option("dragDropRange")
  local pos   = db.actor:position()

  if range > 0 and BS.closestCampfire(pos, range) and BS.burnable(item) then
    BS.burn({item:id()}, true)
  end
end


FUNC.add_functor("burnshit_burn",
  BS.showMenu,
  function()
    return game.translate_string("st_burnshit_burn")
  end,
  nil,
  function(item)
    BS.burn({item:id()})
  end
)


FUNC.add_functor("burnshit_burn_all",
  BS.showMenuAll,
  function()
    return game.translate_string("st_burnshit_burn_all")
  end,
  nil,
  function(item)
    local ids = {}

    db.actor:iterate_inventory(function(owner, other)
      if item:section() == other:section() then
        table.insert(ids, other:id())
      end
    end, db.actor)

    BS.burn(ids)
  end
)


function on_game_start()
  RegisterScriptCallback("actor_on_item_drop", BS.onDropItem)
end
